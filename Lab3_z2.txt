#include <iostream>
#include <windows.h>
#include <math.h>


using namespace std;


template <class T>//начало описания шаблона и список параметров шаблона. Т- имя параметра шаблона.
class set
{
	T* Arr_Set;		// Множество элементов типа данных T
	int size;		// Размер множества элементов типа данных T

	friend istream& operator >> (istream& in, set<int>& other);		// Ввод размера чисел
	friend ostream& operator << (ostream& ut, set<int>& other);		// Вывод множества чисел


public:
	set()
	{

	}
	set(const set& other)
	{
		size = other.size;		// Копируем в объект множества объединения размер temp.size
		Arr_Set = new T[size];
		for (int i = 0; i < size; i++) // Копируем в Объект множества объединения M3 результаты объединения множества M1 и M2
		{
			Arr_Set[i] = other.Arr_Set[i];
		}
	}

	void operator = (const set& other)	// Перегрузка оператора =
	{
		if (Arr_Set != nullptr) delete[] Arr_Set; // Если массив не пустой, то удаляем
		size = other.size;
		Arr_Set = new T[size];

		for (int i = 0; i < size; i++) // Копируем в Объект множества объединения M3 результаты объединения множества M1 и M2
		{
			Arr_Set[i] = other.Arr_Set[i];
		}
	}

	set Union(const set& other)			// Метод объединения множеств
	{
		set temp;

		int sizearr = size + other.size;
		T* arr = new T[sizearr];
		int n = 0;
		for (int i = 0; i < size; i++)			// Добавляем M1 в массив множество объединения
		{
			arr[i] = Arr_Set[i];
			++n;
		}
		for (int i = 0; i < other.size; i++)	// Добавляем M2 в массив множество объединения
		{
			arr[n] = other.Arr_Set[i];
			n++;
		}
		for (int i = 0; i < sizearr; i++)			// Сортируем arr
		{
			for (int i = 0; i < sizearr - 1; i++)
			{
				if (arr[i] > arr[i + 1]) swap(arr[i], arr[i + 1]);
			}
		}
		int k = 0;
		temp.size = sizearr;
		temp.Arr_Set = new T[temp.size];		// Множество объединения размером size M1 + M2
		for (int i = 0; i < sizearr; i++)
		{
			if (i == sizearr - 1)
			{
				temp.Arr_Set[k] = arr[i];
				break;
			}
			if (arr[i] != arr[i + 1])
			{
				temp.Arr_Set[k++] = arr[i];
			}
		}

		delete[] arr;

		temp.size = k + 1;
		temp.Arr_Set = (T*)realloc(temp.Arr_Set, temp.size * sizeof(T));

		return temp;
	}
	set Intersection(const set& other)		// Метод пересечения множеств
	{
		HANDLE color = GetStdHandle(STD_OUTPUT_HANDLE);
		set temp;

		int sizeM1 = size; int sizeM2 = other.size;
		T* arrM1 = new T[sizeM1];			//	M1
		T* arrM2 = new T[sizeM2];			//	M2
		for (int i = 0; i < sizeM1; i++)	// Копируем массив M1
		{
			arrM1[i] = Arr_Set[i];
		}
		for (int i = 0; i < sizeM2; i++)	// Копируем массив M2
		{
			arrM2[i] = other.Arr_Set[i];
		}
		for (int i = 0; i < sizeM1; i++)			// Сортируем M1
		{
			for (int i = 0; i < sizeM1 - 1; i++)
			{
				if (arrM1[i] > arrM1[i + 1]) swap(arrM1[i], arrM1[i + 1]);
			}
		}
		for (int i = 0; i < sizeM2; i++)			// Сортируем M2
		{
			for (int i = 0; i < sizeM2 - 1; i++)
			{
				if (arrM2[i] > arrM2[i + 1]) swap(arrM2[i], arrM2[i + 1]);
			}
		}

		// arr1 и arr2 хранят в себе разные элементы по возрастанию
		int n = 0;
		T* arr = new T[sizeM1 + sizeM2];			// Массив, в который будут копироваться все элементы множества M1 и M2
		for (int i = 0; i < sizeM1; i++)			// Добавляем M1 в массив множество объединения
		{
			arr[i] = arrM1[i];
			n++;
		}
		for (int i = 0; i < sizeM2; i++)	// Добавляем M2 в массив множество объединения
		{
			arr[n] = arrM2[i];
			n++;
		}
		temp.size = n;
		temp.Arr_Set = new T[temp.size];		// Множество объединения размером size M1 + M2
		for (int i = 0; i < n; i++)				// Сортируем
		{
			for (int i = 0; i < n - 1; i++)
			{
				if (arr[i] > arr[i + 1]) swap(arr[i], arr[i + 1]);
			}
		}
		int j = 0;
		for (int i = 0; i < n; i++)				// Исключаем разные элементы
		{
			if (i == n - 1) break;
			else if (arr[i] == arr[i + 1])
			{
				i++;
				temp.Arr_Set[j] = arr[i];
				j++;
			}
		}




		delete[] arrM1;
		delete[] arrM2;
		delete[] arr;
