#include <iostream>
#include <windows.h>
#include <math.h>


using namespace std;

class complex
{
public:
	int** v;
private:
	int rows; int cols = 2; // 0 столбец - действительная часть, 1 столбец - мнимая часть

	friend ostream& operator << (ostream& ut, complex& other);			// Вывод комплексногых чисел
	friend istream& operator >> (istream& in, complex& other);			// Ввод размера комплексных чисел и их инициализация

public:
	complex()
	{

	}
	complex(int size)	// Конструктор с параметрами
	{
		rows = size;
	}

	void ident()						// Объявление динамического массива
	{
		v = new int* [rows];

		for (int i = 0; i < rows; i++)
		{
			v[i] = new int[cols];
		}
	}

	int getRows()
	{
		return rows;
	}
	int** getV()
	{
		return v;
	}

	~complex()
	{
		for (int i = 0; i < rows; i++)
		{
			delete[] v[i];
		}
		delete[] v;
	}
};

template <class T>
class vector
{
private:
	T* v;
	int rows;
	int cols = 2;
	double Module = 0;

	friend ostream& operator << (ostream& ut, vector<int>& other);			// Вывод вектора с целыми числами
	friend ostream& operator << (ostream& ut, vector<double>& other);		// Вывод вектора с вещественными числами
public:
	void ent()							// Заполнение вектора целыми/вещественными числами
	{
		cin >> rows;
		v = new T[rows];
		for (int i = 0; i < rows; i++)
		{
			v[i] = sqrt(rand() % 100);
		}
	}
	void print()						// Вывод целых/вещественных чисел
	{
		cout << "Числа:" << endl;
		for (int i = 0; i < rows; i++)
		{
			cout << "\t" << v[i] << endl;
		}
	}
	void ModuleVect()					// Вычисление длины вектора 
	{
		for (int i = 0; i < rows; i++)
		{
			Module = Module + v[i] * v[i];
		}
		Module = sqrt(Module);
	}
	void PrintModuleVect()				// Вывод длины вектора
	{
		cout << "Длина вектора:\t" << Module << endl << endl;
	}

	~vector()
	{
		delete[] v;
	}
};

template <>
class vector<complex>
{
public:
	complex* ve;
	int rows;
	int cols = 2;
	double* Module;

public:
	vector(complex& other)	// Конструктор копирования || копирование rows
	{
		rows = other.getRows();	// Копируем количество комплексных чисел в вектор с этими комплексными числами
		ve = new complex[rows]; // Объявляем динамический массив из из переменных типа данных complex (комплексные числа)
	}

	void enter(complex& other)	// Метод заполнения вектора комплексными числами
	{
		for (int i = 0; i < rows; i++) // У каждого элемента-объекта с типом данных complex объявляем массив, который будет хранить в себе комплексное число
		{
			ve[i].v = new int* [rows];
			ve[i].v[i] = new int[cols];
		}

		for (int i = 0; i < rows; i++) // Заполняем вектор ve комплексными числами
		{
			ve[i].v[i][0] = other.v[i][0];
			ve[i].v[i][1] = other.v[i][1];
		}
	}

	void ModuleVect()					// Вычисление длины вектора 
	{
		Module = new double[rows];
		for (int i = 0; i < rows; i++)
		{
			Module[i] = 0;
		}
		for (int i = 0; i < rows; i++)
		{
			Module[i] = Module[i] + ve[i].v[i][0] * ve[i].v[i][0] + ve[i].v[i][1] * ve[i].v[i][1];
			Module[i] = sqrt(Module[i]);
		}
	}
	void PrintModuleVect()				// Вывод длины вектора
	{
		cout << "Вектор: ";
		cout << "{ ";
		for (int i = 0; i < rows; i++)
		{
			cout << Module[i];
			if (i != rows - 1) cout << ", ";
		}
		cout << " }" << endl;

		cout << "Длина вектора:\t" << rows << endl << endl;
	}

	~vector()
	{
		delete[] ve;
	}
};

