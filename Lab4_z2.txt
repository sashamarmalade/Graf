if (num == 3)
		{
			int  n;
			vector  <int>  v;
			vector<int>::const_iterator i;
			ifstream in("test.txt");
			
			if (!in) { cerr << "Файл не найден\n"; exit(1); }
			int x;
			while (in >> x)
				v.push_back(x); // записываем очередное значение в конец вектора

			cout << "Размер вектора: " << v.size() << endl;
			cout << "Содержимое вектора:\n" << endl;

			input(v, i);

			cout << endl << endl << "----------Задание 2.1----------" << endl;

			cout << endl << "Введите искомое число: ";
			cin >> n;

			int сount_n = count(v.begin(), v.end(), n);

			list<int> loc_list; // список позиций искомой величины
			vector<int>::iterator  location = v.begin();
			while (1)
			{
				// находим очередную позицию искомого значения, начиная с позиции //location
				location = find(location, v.end(), n);
				if (location == v.end())
					break;
				loc_list.push_back(location - v.begin());// помещаем в список номер элемента
				location++; // переходим к следующей позиции
			}
			//вывод элементов полученного  списка
			list<int>::iterator p = loc_list.begin(); // итератор для прохода по списку
			if (сount_n == 0)
			{
				cout << endl << "Числa " << n << " в векторе нет." << endl;
			}
			else {
				cout << "Число " << n << " находится на позиции(ях): ";

				for (p; p != loc_list.end(); ++p)
					cout << *p << ' ';   // вывод значений элементов списка

				cout << endl << "Число " << n << " встречается в векторе " << сount_n << " раз(a)." << endl;
			}

			cout << endl << "----------Задание 2.2----------" << endl << endl;

			int сount_n_e = count_if(v.begin(), v.end(), [](int x) { return (x % 2 == 0); });// количество четных элементов
			int сount_n_une = count_if(v.begin(), v.end(), [](int x) { return (x % 2 != 0); });// количество нечетных элементов

			cout << "Количество четных чисел: " << сount_n_e << endl;
			cout << "Количество нечетных чисел: " << сount_n_une << endl;

			cout << "Четное(ые) число(а) находится(ятся) на позиции(ях):";
			//Список для хранения номеров четных элементов
			list<int> loc_list1;
			// список формируется аналогично предыдущему случаю, только //используется функция find_if, третий параметр – имя функции, //проверяющей четность
			location = v.begin();
			while (1)
			{
				location = find_if(location, v.end(), [](int x) { return (x % 2 == 0); });
				if (location == v.end())
					break;
				loc_list1.push_back(location - v.begin());
				location++;
			}
			// используем итератор, описанный для списков 
			p = loc_list1.begin();
			int sum = 0;
			for (p; p != loc_list1.end(); ++p)
			{
				cout << *p << ' ';   //выводим номера четных элементов       
			}
			if (сount_n_e > сount_n_une) {
				for (p; p != loc_list1.end(); ++p)
					sum += v[*p];  //находим сумму элементов вектора, номера берем из списка    
				cout << endl << "Сумма четных элементов: " << sum << endl;
			}
			else
			{
				for (i = v.begin(); i != v.end(); ++i)
					sum += *i;
				cout << endl << "Сумма всех элементов: " << sum << endl;
			}

